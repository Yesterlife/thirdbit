---
title: "Yep, More Books"
date: 2008-05-05 11:28:00
---
I believe very strongly that if you want to write well, you have to read relentlessly and critically: relentlessly, because there's a lot out there, and critically, because you must always be asking yourself, "What's good about this?  What's bad?  What do I want to imitate? What mistakes do I want to avoid?"  I keep going back to the trilogy Kernighan and colleagues wrote in the 1980s (<cite>The C Programming Language</cite>, <cite>The Unix Programming Environment</cite>, <cite>Software Tools in Pascal</cite>), just as musicians I know go back to Coltrane's early recordings or bootlegs of The Cure; I think a lot of books about computing would be greatly improved if their authors would do the same.

Take Flaig's <cite>Bioinformatics Programming in Python</cite>, for example.  It is as pretentious as Kernighan's books are unassuming, and by trying to cover everything the author knows about computing, it manages to take the reader nowhere.  The trouble starts right at the beginning, with a page about Japanese swordplay that ends, "Do yourself a favor and think about this man's advice," and the realization that the book is divided into sections called "Earth", "Water", "Fire", "Air", and "Void" (only the first two of which are included in these 418 pages).  There are endless references to other languages (particularly Haskell and Erlang), which I believe will only muddy the exposition for newcomers to Python, and far too many attempts to be clever that only fall flat.  Lots of interesting and useful topics are actually covered, but it's impossible to see past the author to the book's content.

Berman's <cite>Ruby Programming for Medicine and Biology</cite> is a much better book, though still flawed.  Berman comes from a medical background, and after years of wrestling with odd data formats and Perl's syntax, he has discovered RDF and Ruby, and thinks they've got sliced bread beat cold.  Those parts of the book that describe how to grind biomedical data with Ruby are very strong; I learned things about both the language and medical data crunching that I hadn't known before.  I particularly liked the pragmatism of some of the examples: it isn't every book that shows you how to put an RDF header in a JPEG image.

However, the book does have three flaws.  The first is the example-driven way Ruby's features are introduced: a reader who doesn't already know how to program in a modern scripting language is going to have a hard time following along.  The second is the side trips into topics like data formats: I thought they were awkwardly placed, and just long enough to distract readers from learning to program.  Finally, I agree that RDF and Ruby are a step up from flat ASCII and Perl, but Berman's claim that Ruby's features map "naturally" onto RDF and vice versa grated a little: I could make arguments that were just as strong for half a dozen other languages, with just as little data to back them up.

LeBlanc and Dyer's <cite>Perl for Exploring DNA</cite> doesn't try to go as far as Flaig's or Berman's books, but is thereby more useful for working scientists.  The authors are a computer scientist and a biologist respectively, and while they'll never convince me to like Perl, their combination of clean prose and clear examples make for a readable and informative guide to everything from lists and functions to regular expressions and databases.  They don't assume too much or too little of their readers, and the occasional typo didn't impede comprehension.  The only thing I'd ask them to change is the quality of their fuzzy screen captures...

Harrop's <cite>OCaml for Scientists</cite> and Odersky et al's <cite>Programming in Scala</cite> share the same basic flaw as Berman's book: the authors' belief in what they're trying to explain gets in the way of their explanations.  The "what" in both cases is functional programming using either a language that's been around for years, like OCaml, or one that's relatively new, like Scala.  Harrop's style is stodgy ("As some approaches to pattern matching lead to more robust programs, some notions of good and bad programming styles arise in the context of pattern matching."), while Odersky et al are almost gushing at points, but both have a habit of waving away the shortcomings of their subjects.  Kernighan and Ritchie didn't try to sell C; they described it, and let readers make up their own minds. It's a model worth imitating.

Next this month (gosh, I <em>have</em> been on a lot of flights, haven't I?) is <cite>The ThoughtWorks Anthology</cite>, a collection of essays from developers and managers at a consulting firm that counts among its staff several luminaries from the design patterns/refactoring/agile world.  Some chapters, like Singham and Robinson's "Solving the Business Software 'Last Mile'" or Parsons' "The Lush Landscape of Languages", are high-level handwaving, but there are several gems: Lentz on "What Is an Iteration Manager Anyway?", Pantazopoulos on "Project Vital Signs", and (my favorite) Simpson on "Refactoring Ant Build Files".  If the book had been a blog, I would have read about half the posts end-to-end, which is a pretty good hit rate.

Finally there is <cite>Head First Software Development</cite>, the latest in O'Reilly's not-quite-cartoon series aimed at developers with short attention spans.  (OK, that's a bit unfair, but that's what it feels like to read them.)  Take away the jokiness, crossword puzzles, and thought-bubbles, and this is actually a really good book: mostly agile in approach, but refreshingly free of dogmatism, and intensely practical.  If you're trying to get the most out of a team of a dozen programmers, you won't find many better roadmaps than this; if it was half its current size (which it could be), I'd seriously consider adopting it as a textbook in my third-year software engineering class.

<hr />ThoughtWorks Inc.: <a href="http://www.amazon.com/ThoughtWorks-Anthology-Technology-Innovation-Programmers/dp/193435614X"><cite>The Thoughtworks Anthology</cite></a>.  Pragmatic Bookshelf, 2008, 193435614X.

Jules J. Berman: <a href="http://www.amazon.com/Programming-Medicine-Bartlett-Biomedical-Informatics/dp/0763750905"><cite>Ruby Programming for Medicine and Biology</cite></a> Jones &amp; Bartlett, 2007, 0763750905.

Ruediger-Marcus Flaig: <a href="http://www.amazon.com/Bioinformatics-Programming-Python-Practical-Beginners/dp/3527320946"><cite>Bioinformatics Programming in Python</cite></a>.  Wiley-VCH, 2008, 3527320946.

Jon D. Harrop: <a href="http://www.ffconsultancy.com/products/ocaml_for_scientists/"><cite>OCaml for Scientists</cite></a>.  Flying Frog Consultancy, 2007.

Mark D. LeBlanc and Betsey Dexter Dyer: <a href="http://www.amazon.com/Perl-Exploring-DNA-Mark-LeBlanc/dp/0195305892"><cite>Perl for Exploring DNA</cite></a>.  Oxford University Press, 2007, 0195305892.

Martin Odersky, Lex Spoon, and Bill Venners: <cite>Programming in Scala</cite>.  Artima, 2008.

Dan Pilone and Russ Miles: <a href="http://www.amazon.com/First-Software-Development-Brain-Friendly-Guides/dp/0596527357"><cite>Head First Software Development</cite></a>.  O'Reilly, 2008, 0596527357.
